/* Copyright 2005-2025 Varghese Mathew (Matt)
 *
 * This file is part of Coconut (TM).
 * Coconut is a
 *     Multi-threaded simulation of the pipeline of a MIPS-like
 *     Microprocessor (integer instructions only) replete with 
 *     Memory Subsystem, Caches and their performance analysis,
 *     I/O device modules and an assembler.
 * 
 * Coconut is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Coconut is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Coconut.  If not, see <http://www.gnu.org/licenses/>.
 */
 
#include "util.h"
#include "lexer.h"
#include "parser.h"
#include "codegen.h"

#include <iostream>
#include <fstream>
#include <string>

static bool has_suffix(const std::string& s, const std::string& suf) {
  if (s.size() < suf.size()) return false;
  return s.compare(s.size() - suf.size(), suf.size(), suf) == 0;
}

int main(int argc, char** argv) {
  try {
    if (argc != 2) {
      std::cerr << "Usage: smallc <file.smallc.c>\n";
      return 1;
    }

    std::string inPath = argv[1];
    const std::string requiredExt = ".smallc.c";

    // 1) Enforce input extension
    if (!has_suffix(inPath, requiredExt)) {
      throw CompileError(
        "Input file must have extension " + requiredExt
      );
    }

    // 2) Derive output filename
    // factorial.smallc.c -> factorial.smallc.mips
    std::string outPath =
      inPath.substr(0, inPath.size() - 2) + ".mips";

    if (!has_suffix(outPath, ".smallc.mips")) {
      throw CompileError("Internal error computing output filename");
    }

    // 3) Read input
    std::string src = read_file(inPath);

    // 4) Compile
    Lexer lex(src);
    Parser parser(std::move(lex));
    Program prog = parser.parse_program();

    CodeGen cg;
    std::string asmText = cg.compile(prog);

    // 5) Write output with header
    std::ofstream out(outPath, std::ios::binary);
    if (!out) {
      throw CompileError("Unable to write output file: " + outPath);
    }

    out << "# Generated by SmallC\n";
    out << "# Source: " << inPath << "\n";
    out << "\n";
    out << asmText;

    std::cout << "Compiled " << inPath << " -> " << outPath << "\n";
    return 0;

  } catch (const CompileError& e) {
    std::cerr << "SmallC compile error: " << e.what() << "\n";
    return 2;
  } catch (const std::exception& e) {
    std::cerr << "Fatal error: " << e.what() << "\n";
    return 3;
  }
}
